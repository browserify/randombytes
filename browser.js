'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function generateBytes (buffer) {
  // in case browserify isn't using the Uint8Array version
  var rawBytes = new global.Uint8Array(buffer.length)

  // getRandomValues fails on IE if size == 0
  if (buffer.length > 0) {
    // This will not work in older browsers.
    // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
    crypto.getRandomValues(rawBytes)
  }

  // copy generated bytes
  for (var i = 0; i < rawBytes.length; i++) {
    buffer[i] = rawBytes[i]
  }
}

function randomBytes (size, cb) {
  if (isNaN(size) || size < 0) {
    throw new Error('size must be a number >= 0')
  }

  if (size > MAX_UINT32) {
    throw new Error('Requested too many random bytes - the maximum allowed are ' + MAX_UINT32)
  }

  var bytes = Buffer.alloc(size)

  // we can only generate MAX_BYTES at a time
  for (var generated = 0; generated < size; generated += MAX_BYTES) {
    var nextChunk = generated + MAX_BYTES > size ? size - generated : MAX_BYTES

    generateBytes(bytes.slice(generated, generated + nextChunk))
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  } else {
    return bytes
  }
}
